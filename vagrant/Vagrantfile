# Constants for configuration

VM_CPUS = 2
VM_GUI = false
VM_MEMORY = "4096"
VM_IP = "192.168.56.189" # The default subnet for Vagrant's private network is 192.168.56.0/24
VM_NAME = "WINDOWS_SERVER"
VM_HOSTNAME = "windows-2019-vagrant"

BOOT_TIMEOUT = 1200
VAGRANT_PROVIDER = "virtualbox"

# VAGRANT_BOX_VERSION = "2021.05.15"
# VAGRANT_BOX_NAME = "StefanScherer/windows_2019"

VAGRANT_BOX_VERSION = "2021.08.23"
VAGRANT_BOX_NAME = "StefanScherer/windows_2022"

# TODO: enable https communication only
WINRM_TIMEOUT = 1200
WINRM_MAX_TRIES = 300
WINRM_RETRY_DELAY = 5
WINRM_HTTP_PORT = 55985
WINRM_HTTPS_PORT = 55986
VM_COMMUNICATOR = "winrm"
WINRM_USERNAME = "vagrant"
WINRM_PASSWORD = "vagrant"

HTTPS_ENABLED = true
HTTPS_CONFIGURED_FLAG_FILE = ".vagrant/machines/#{VM_NAME}/virtualbox/https_configured.flag"

CERT_EXPORT_FILE_NAME = "winrm-cert.pfx"
SRC_CERT_FILE_PATH = "./certs/" + CERT_EXPORT_FILE_NAME
DEST_CERT_FILE_PATH = "C:/certs/" + CERT_EXPORT_FILE_NAME

# Define the custom provisioner module to run commands on host
# Example usage: config.vm.provision "list-files", type: "local_shell", command: "ls"
module LocalCommand
  class Config < Vagrant.plugin("2", :config)
    attr_accessor :command
  end

  class Plugin < Vagrant.plugin("2")
    name "local_shell"

    config(:local_shell, :provisioner) do
      Config
    end

    provisioner(:local_shell) do
      Provisioner
    end
  end

  class Provisioner < Vagrant.plugin("2", :provisioner)
    def provision
      # Split the multi-line command into individual commands
      commands = config.command.split("\n").map(&:strip).reject(&:empty?)

      # Execute each command in sequence
      commands.each do |command|
        result = system(command)
        raise "Command failed: #{command}" unless result
      end
    end
  end
end

class GuestAdditionsProvisioner
  ISO_MOUNT_DRIVE = "E:"
  ISO_DESTINATION_VM = "C:/VBoxGuestAdditions.iso"
  GUEST_ADDITIONS_EXECUTABLE = "VBoxWindowsAdditions.exe"
  GUEST_ADDITIONS_ISO = "C:/Program Files/Oracle/VirtualBox/VBoxGuestAdditions.iso"
  GUEST_ADDITIONS_FLAG_FILE = ".vagrant/machines/#{VM_NAME}/virtualbox/guest_additions_updated.flag"

  def initialize(config)
    @config = config
    ensure_flag_directory
  end

  # Public method to provision Guest Additions
  def provision
    # Check if the flag file to indicate that Guest Additions have been updated exists
    # And only proceed if it does not exist
    if guest_additions_updated?
      @config.trigger.after :up do |trigger|
        trigger.name = "Skipping VBoxGuestAdditions installation"
        trigger.run = { inline: "Write-Host '[Vagrant] VBoxGuestAdditions already updated, skipping installation.'" }
      end
    else
      copy_guest_additions_iso
      install_guest_additions
      create_flag_file
    end
  end

  private

  # Ensure the flag file directory exists
  def ensure_flag_directory
    FileUtils.mkdir_p(File.dirname(GUEST_ADDITIONS_FLAG_FILE))
  end

  # Check if Guest Additions have already been updated
  def guest_additions_updated?
    File.exist?(GUEST_ADDITIONS_FLAG_FILE)
  end

  # Copy the VBoxGuestAdditions ISO to the VM
  def copy_guest_additions_iso
    @config.vm.provision "file", source: GUEST_ADDITIONS_ISO, destination: ISO_DESTINATION_VM
  end

  # Mount and install the Guest Additions ISO
  def install_guest_additions
    @config.vm.provision "shell", inline: <<-SHELL
        Mount-DiskImage -ImagePath "#{ISO_DESTINATION_VM}"
        Start-Sleep -Seconds 10
        if (Test-Path "#{ISO_MOUNT_DRIVE}\\#{GUEST_ADDITIONS_EXECUTABLE}") {
            Start-Process "#{ISO_MOUNT_DRIVE}\\#{GUEST_ADDITIONS_EXECUTABLE}" -ArgumentList "/S" -NoNewWindow -Wait
        }
        Dismount-DiskImage -ImagePath "#{ISO_DESTINATION_VM}"
        Write-Host "[Vagrant] Guest Additions have been updated successfully."
    SHELL
  end

  # Create a flag file on the host
  def create_flag_file
    @config.vm.provision "guest_additions_updated_marker",
      type: "local_shell",
      command: <<-SHELL
        echo 'Guest Additions updated on #{Time.now}' > "#{GUEST_ADDITIONS_FLAG_FILE}"
        echo '[Vagrant] Guest Additions updation flag created on host.'
      SHELL
  end
end

Vagrant.configure("2") do |config|
    config.trigger.before :up do |trigger|
        trigger.name = "Log Start"
        trigger.run = { inline: <<-SCRIPT
                Write-Host "[INFO] Vagrant is starting at: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
            SCRIPT
        }
    end

    config.vm.box = VAGRANT_BOX_NAME
    config.vm.box_version = VAGRANT_BOX_VERSION

    # Set up VM hostname
    config.vm.define VM_NAME
    config.vm.hostname = VM_HOSTNAME

    # Increase WinRM timeout to allow VM more time to boot
    config.vm.boot_timeout = BOOT_TIMEOUT

    # Set up the VM to use a private network
    config.vm.network "private_network", type: "static", ip: VM_IP

    config.vm.provider VAGRANT_PROVIDER do |vb|
        vb.gui = VM_GUI
        vb.cpus = VM_CPUS
        vb.name = VM_NAME
        vb.memory = VM_MEMORY
    end

    # Set the guest OS type
    config.vm.guest = :windows

    if !File.exist?(HTTPS_CONFIGURED_FLAG_FILE)
        config.winrm.transport = :plaintext
        config.winrm.client.basic_auth_only = true
        config.winrm.port = WINRM_HTTP_PORT
    else
        config.winrm.transport = :ssl
        config.winrm.port = WINRM_HTTPS_PORT
        config.winrm.ssl_peer_verification = false
    end

    # Set WinRM transport, username, password, and port
    config.winrm.timeout = WINRM_TIMEOUT
    config.winrm.username = WINRM_USERNAME
    config.winrm.password = WINRM_PASSWORD
    config.winrm.max_tries = WINRM_MAX_TRIES # default is 20
    config.winrm.retry_delay = WINRM_RETRY_DELAY

    # Set the communicator for VM
    config.vm.communicator = VM_COMMUNICATOR

    GuestAdditionsProvisioner.new(config).provision

    # Verify IP configuration
    config.vm.provision :shell, :path => 'scripts/check_ip.ps1', :args => [VM_IP]

    # Configuring Service Account for Ansible
    config.vm.provision "shell", path: "scripts/setup_ansible_user.ps1"

    if HTTPS_ENABLED && !File.exist?(HTTPS_CONFIGURED_FLAG_FILE)
       # Run the PowerShell script on the host to generate and import ssl certificate on HOST if not yet done
        config.trigger.before :up do |trigger|
            trigger.name = "Generate SSL Cert on Host"
            trigger.run = { inline: "powershell -ExecutionPolicy Bypass -File scripts/generate_ssl_cert_on_host.ps1" }
        end
        # Copy certificate from host to guest (Not required for simple HTTP)
        config.vm.provision "file", source: SRC_CERT_FILE_PATH, destination: DEST_CERT_FILE_PATH

        # Provision WinRM HTTPS configuration
        # Running this through trigger from host as it has troubles running from config.vm.provision "shell".
        config.trigger.after :up do |trigger|
            trigger.name = "Configure WinRM HTTPS"
            trigger.run = {
                inline: <<-SHELL
                    $SecurePassword = ConvertTo-SecureString '#{WINRM_PASSWORD}' -AsPlainText -Force
                    $Credential = New-Object System.Management.Automation.PSCredential `
                                                              ('#{WINRM_USERNAME}', $SecurePassword)
                    Invoke-Command -ComputerName 127.0.0.1 -Port #{WINRM_HTTP_PORT} `
                        -FilePath './scripts/setup_winrm_https.ps1' `
                        -Credential $Credential

                    # Check if the Invoke-Command was successful
                    if ($?) {
                        echo "[INFO] HTTPS configuration completed on #{Time.now}" > "#{HTTPS_CONFIGURED_FLAG_FILE}"
                        Write-Host "*****************************************************************************************"
                        Write-Host "[INFO] Run ``vagrant up --provision`` to make winrm on vagrant run with SSL."
                        Write-Host "[INFO] If you want to switch back to HTTP after enabling HTTPS"
                        Write-Host "[INFO] you need to first run ``vagrant destroy -f` and then ``vagrant up --provision``."
                        Write-Host "[INFO] OR if you do not want to run ``destroy` and then ``provision`` commands for HTTP switch"
                        Write-Host "[INFO] THEN run:"
                        # The runnable command: `winrs -r:http://localhost:55985 -u:vagrant -p:vagrant powershell -Command "Set-Item -Path 'WSMan:\localhost\Service\AllowUnencrypted' -Value $true"`
# It doesn't like spaces, so has to be in the beginning of the line
$setItemCommand = @'
`winrs -r:http://localhost:'#{WINRM_HTTP_PORT}' -u:'#{WINRM_USERNAME}' -p:'#{WINRM_PASSWORD}' powershell -Command "Set-Item -Path 'WSMan:\\localhost\\Service\\AllowUnencrypted' -Value $true"`
'@
                        Write-Host $setItemCommand
                        Write-Host "*****************************************************************************************"
                    } else {
                        Write-Host '[ERROR] HTTPS configuration failed.'
                    }
                SHELL
            }
        end
    else
        config.trigger.after :up do |trigger|
            trigger.name = "Skipping WinRM HTTPS Configuration"
            script = if HTTPS_ENABLED && File.exist?(HTTPS_CONFIGURED_FLAG_FILE)
                        'Write-Host "[INFO] Skipping HTTPS configuration as it is already configured."'
                     else
                        'Write-Host "[INFO] Skipping HTTPS configuration as it is not required."'
                     end
            trigger.run = { inline: script }
        end
    end

    # Additional provisioning steps (if needed) can be added here

    config.trigger.after :up do |trigger|
        trigger.name = "Log End"
        trigger.run = { inline: <<-SCRIPT
                Write-Host "[INFO] Vagrant has finished at $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
            SCRIPT
        }
    end
end
